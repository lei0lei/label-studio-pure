{"version":3,"file":"943.js","mappings":"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","sources":["webpack://labelstudio/../../libs/editor/src/lib/AudioUltra/Analysis/MelBanks.ts","webpack://labelstudio/../../libs/editor/src/lib/AudioUltra/Analysis/FFTProcessor.ts","webpack://labelstudio/../../libs/editor/src/lib/AudioUltra/Visual/WindowFunctions.ts"],"sourcesContent":["/**\r\n * Handles the creation and application of Mel filter banks for audio analysis.\r\n */\r\nexport class MelBanks {\r\n  private filterbank: number[][];\r\n  private numBands: number;\r\n\r\n  /**\r\n   * Initializes the MelBanks instance and creates the filterbank.\r\n   *\r\n   * @param sampleRate - The sample rate of the audio.\r\n   * @param linearBinCount - The number of frequency bins in the linear spectrum (fftSize / 2 + 1).\r\n   * @param numBands - The desired number of Mel bands.\r\n   */\r\n  constructor(sampleRate: number, linearBinCount: number, numBands: number) {\r\n    if (numBands <= 0) {\r\n      console.warn(\"Number of Mel bands must be positive.\");\r\n      // Provide a default empty filterbank to avoid errors later\r\n      this.filterbank = [];\r\n      this.numBands = 0;\r\n    } else {\r\n      this.numBands = numBands;\r\n      this.filterbank = this.createMelFilterbank(sampleRate, linearBinCount, numBands);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies the pre-calculated Mel filter bank to a linear power spectrum.\r\n   *\r\n   * @param linearSpectrum - The input linear power spectrum (magnitudes).\r\n   * @returns The spectrum converted to the Mel scale.\r\n   */\r\n  applyFilterbank(linearSpectrum: Float32Array): Float32Array {\r\n    if (this.filterbank.length === 0 || this.numBands === 0) {\r\n      console.warn(\"Mel filter bank not initialized or invalid.\");\r\n      // Return an empty or zero-filled array matching the expected band count\r\n      return new Float32Array(this.numBands).fill(0);\r\n    }\r\n\r\n    // Ensure the filter bank bin count matches linear spectrum length\r\n    if (this.filterbank.length > 0 && this.filterbank[0].length !== linearSpectrum.length) {\r\n      console.error(\r\n        `Mel filter bank bin count (${this.filterbank[0].length}) does not match linear spectrum length (${linearSpectrum.length}). Recreate MelBanks instance.`,\r\n      );\r\n      return new Float32Array(this.numBands).fill(0);\r\n    }\r\n\r\n    const melSpectrum = new Float32Array(this.numBands).fill(0);\r\n    for (let i = 0; i < this.numBands; i++) {\r\n      const filter = this.filterbank[i];\r\n      // filter bank[0].length should equal linearSpectrum.length due to check above\r\n      for (let j = 0; j < filter.length; j++) {\r\n        melSpectrum[i] += linearSpectrum[j] * filter[j];\r\n      }\r\n      // Add a small epsilon to avoid log(0) if further log scaling is applied later\r\n      melSpectrum[i] = melSpectrum[i] > 0 ? melSpectrum[i] : 1e-10;\r\n    }\r\n\r\n    return melSpectrum;\r\n  }\r\n\r\n  /**\r\n   * Converts frequency in Hz to Mel scale.\r\n   */\r\n  private hzToMel(hz: number): number {\r\n    return 2595 * Math.log10(1 + hz / 700);\r\n  }\r\n\r\n  /**\r\n   * Converts Mel scale value back to frequency in Hz.\r\n   */\r\n  private melToHz(mel: number): number {\r\n    return 700 * (10 ** (mel / 2595) - 1);\r\n  }\r\n\r\n  /**\r\n   * Creates a Mel filter bank matrix.\r\n   */\r\n  private createMelFilterbank(sampleRate: number, linearBinCount: number, numBands: number): number[][] {\r\n    // Basic parameter validation\r\n    if (numBands <= 0 || linearBinCount <= 1 || sampleRate <= 0) {\r\n      console.warn(\"Invalid parameters for Mel filterbank creation.\");\r\n      return [];\r\n    }\r\n\r\n    const lowFreqMel = 0;\r\n    const highFreqMel = this.hzToMel(sampleRate / 2);\r\n\r\n    // Check for degenerate Mel range\r\n    if (lowFreqMel >= highFreqMel) {\r\n      console.warn(\"Min Mel frequency is not less than Max Mel frequency.\");\r\n      return [];\r\n    }\r\n\r\n    const melPoints = new Float32Array(numBands + 2);\r\n    const melStep = (highFreqMel - lowFreqMel) / (numBands + 1);\r\n\r\n    // Check for a non-positive Mel step\r\n    if (melStep <= 0) {\r\n      console.warn(\"Calculated Mel step is not positive.\");\r\n      return [];\r\n    }\r\n\r\n    // Create evenly spaced points in a Mel scale\r\n    for (let i = 0; i < numBands + 2; i++) {\r\n      melPoints[i] = lowFreqMel + i * melStep;\r\n    }\r\n\r\n    const hzPoints: Float32Array = melPoints.map((mel) => this.melToHz(mel));\r\n    // Calculate the frequency resolution of the linear FFT bins\r\n    const freqResolution: number = sampleRate / (2 * (linearBinCount - 1));\r\n    const binFreqs: Float32Array = new Float32Array(linearBinCount).map((_, i) => i * freqResolution);\r\n\r\n    const filterbank: number[][] = [];\r\n    for (let i = 0; i < numBands; i++) {\r\n      const filter = new Array(linearBinCount).fill(0);\r\n      const leftHz = hzPoints[i];\r\n      const centerHz = hzPoints[i + 1];\r\n      const rightHz = hzPoints[i + 2];\r\n\r\n      // Check for non-positive frequency steps which cause division by zero\r\n      const leftDelta = centerHz - leftHz;\r\n      const rightDelta = rightHz - centerHz;\r\n\r\n      // Handle degenerate filters where the triangle collapses due to discretization\r\n      if (leftDelta <= 0 || rightDelta <= 0) {\r\n        // Visual Fix: Instead of a zero-energy filter (causing a dark line\r\n        // in the spectrogram), assign a weight of 1.0 to the single FFT bin\r\n        // closest to the center frequency. This passes the energy from that bin\r\n        // through, avoiding the artifact, although it's not true Mel filtering\r\n        // for this specific band.\r\n        console.warn(\r\n          `Degenerate filter shape detected for Mel band ${i} (center: ${centerHz.toFixed(\r\n            2,\r\n          )} Hz). Applying visual fix.`,\r\n        );\r\n        // Find the bin index closest to the center frequency\r\n        const targetBinIndex = Math.round(centerHz / freqResolution);\r\n        // Ensure the index is within bounds\r\n        const clampedBinIndex = Math.max(0, Math.min(linearBinCount - 1, targetBinIndex));\r\n        if (clampedBinIndex >= 0 && clampedBinIndex < linearBinCount) {\r\n          filter[clampedBinIndex] = 1.0;\r\n        }\r\n        // No need to continue; push the filter with the single '1'\r\n      } else {\r\n        // Normal filter calculation for non-degenerate triangles\r\n        for (let j = 0; j < linearBinCount; j++) {\r\n          const freq = binFreqs[j];\r\n          // Rising slope\r\n          if (freq >= leftHz && freq <= centerHz) {\r\n            filter[j] = (freq - leftHz) / leftDelta;\r\n          }\r\n          // Falling slope\r\n          else if (freq > centerHz && freq <= rightHz) {\r\n            filter[j] = (rightHz - freq) / rightDelta;\r\n          }\r\n        }\r\n      }\r\n      filterbank.push(filter);\r\n    }\r\n    return filterbank;\r\n  }\r\n}\r\n","import webfft from \"webfft\";\r\nimport { applyWindowFunction, type WindowFunctionType } from \"../Visual/WindowFunctions\";\r\nimport { MelBanks } from \"./MelBanks\";\r\nimport { SPECTROGRAM_DEFAULTS } from \"../Visual/constants\";\r\n\r\nexport type SpectrogramScale = \"linear\" | \"log\" | \"mel\";\r\n\r\nexport interface FFTProcessorOptions {\r\n  fftSamples: number;\r\n  windowingFunction: WindowFunctionType;\r\n  sampleRate?: number;\r\n}\r\n\r\n/**\r\n * Handles the core FFT calculations, windowing, and Mel scale conversion.\r\n */\r\nexport class FFTProcessor {\r\n  private options: FFTProcessorOptions;\r\n  private webfftInstance: webfft | null = null;\r\n\r\n  // Added a cache for MelBanks instances to avoid recreating them constantly\r\n  private melBanksCache: MelBanks | null = null;\r\n  private melBanksCacheKey: string | null = null;\r\n\r\n  // Persistent buffers for performance\r\n  private fftInputBuffer: Float32Array | null = null;\r\n  private fftInterleavedInputBuffer: Float32Array | null = null;\r\n\r\n  constructor(options: FFTProcessorOptions) {\r\n    this.options = {\r\n      ...options,\r\n      fftSamples: options.fftSamples || SPECTROGRAM_DEFAULTS.FFT_SAMPLES,\r\n      windowingFunction: options.windowingFunction || \"hann\",\r\n    };\r\n    this.initialize();\r\n  }\r\n\r\n  private initialize() {\r\n    try {\r\n      this.webfftInstance = new webfft(this.options.fftSamples);\r\n      // Run profiling immediately after initialization\r\n      (this.webfftInstance as any).profile();\r\n\r\n      // Pre-allocate buffers\r\n      this.fftInputBuffer = new Float32Array(this.options.fftSamples);\r\n      // webfft might need interleaved input (real, imag, real, imag, ...)\r\n      this.fftInterleavedInputBuffer = new Float32Array(this.options.fftSamples * 2);\r\n    } catch (_error) {\r\n      this.webfftInstance = null;\r\n      this.fftInputBuffer = null;\r\n      this.fftInterleavedInputBuffer = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates FFT parameters. Re-initializes FFT instance and Mel filterbank if necessary.\r\n   */\r\n  updateParameters(newOptions: Partial<FFTProcessorOptions>) {\r\n    const needsReinitialization = newOptions.fftSamples && newOptions.fftSamples !== this.options.fftSamples;\r\n    // Check if the sampleRate changed, as it affects MelBanks\r\n    const needsMelCacheClear = newOptions.sampleRate && newOptions.sampleRate !== this.options.sampleRate;\r\n\r\n    this.options = { ...this.options, ...newOptions };\r\n\r\n    if (needsReinitialization) {\r\n      this.webfftInstance?.dispose(); // Clean up old instance if exists\r\n      this.initialize(); // Re-initialize with a new size\r\n      this.melBanksCache = null; // Clear MelBanks cache if FFT size changes\r\n      this.melBanksCacheKey = null;\r\n    } else if (needsMelCacheClear) {\r\n      this.melBanksCache = null; // Clear MelBanks cache if the sample rate changes\r\n      this.melBanksCacheKey = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculates the power spectrum for a given audio buffer segment.\r\n   * Applies windowing function before FFT.\r\n   * Handles potential errors during FFT calculation.\r\n   *\r\n   * @param buffer The input audio data segment.\r\n   * @returns The power spectrum (magnitude) or null if FFT failed.\r\n   */\r\n  calculatePowerSpectrum(buffer: Float32Array): Float32Array | null {\r\n    if (!this.webfftInstance || !this.fftInputBuffer || !this.fftInterleavedInputBuffer || buffer.length === 0) {\r\n      return this.handleFFTError();\r\n    }\r\n\r\n    // Ensure the input buffer has the correct data, applying windowing\r\n    // Use slice(0, fftSamples) in case the input buffer is longer\r\n    const inputSlice = buffer.slice(0, this.options.fftSamples);\r\n\r\n    // Copy sliced data into the pre-allocated buffer\r\n    // Pad with zeros if inputSlice is shorter than fftSamples\r\n    this.fftInputBuffer.set(inputSlice);\r\n    if (inputSlice.length < this.options.fftSamples) {\r\n      this.fftInputBuffer.fill(0, inputSlice.length);\r\n    }\r\n\r\n    // Now apply the window function IN-PLACE to the fftInputBuffer\r\n    applyWindowFunction(this.fftInputBuffer, this.options.windowingFunction);\r\n\r\n    try {\r\n      // Prepare interleaved input for webfft (assuming real input)\r\n      for (let i = 0; i < this.options.fftSamples; i++) {\r\n        this.fftInterleavedInputBuffer[2 * i] = this.fftInputBuffer[i]; // Real part (now correctly windowed)\r\n        this.fftInterleavedInputBuffer[2 * i + 1] = 0; // Imaginary part\r\n      }\r\n\r\n      // Perform FFT\r\n      const fftResult = this.webfftInstance.fft(this.fftInterleavedInputBuffer);\r\n\r\n      // Add a check for a valid FFT result\r\n      if (!fftResult) {\r\n        console.error(\"WebFFT returned invalid result\", fftResult);\r\n        return this.handleFFTError();\r\n      }\r\n\r\n      // Cast the result after the check using any as a workaround\r\n      const validFftResult = fftResult as any;\r\n\r\n      // Calculate magnitude (power spectrum)\r\n      // Output is complex (real, imag), we need sqrt(real^2 + imag^2)\r\n      // Result is half the size + 1 (due to symmetry)\r\n      const spectrumSize = this.options.fftSamples / 2 + 1;\r\n      const powerSpectrum = new Float32Array(spectrumSize);\r\n      const normFactor = this.options.fftSamples; // Normalization factor (FFT size)\r\n\r\n      // Handle DC component (index 0)\r\n      const dcReal = validFftResult[0];\r\n      powerSpectrum[0] = Math.abs(dcReal) / normFactor;\r\n\r\n      // Handle remaining bins up to Nyquist\r\n      for (let i = 1; i < spectrumSize; i++) {\r\n        const real = validFftResult[2 * i];\r\n        const imag = validFftResult[2 * i + 1];\r\n        // Normalize the magnitude\r\n        // Note: Standard normalization often uses N for power, 2/N for amplitude spectrum (excluding DC/Nyquist)\r\n        // We are calculating power (magnitude squared implicitly via dB conversion later),\r\n        // but normalizing magnitude by N here is common before dB.\r\n        powerSpectrum[i] = Math.sqrt(real * real + imag * imag) / normFactor;\r\n      }\r\n\r\n      return powerSpectrum;\r\n    } catch (error) {\r\n      console.error(\"Error during FFT calculation:\", error);\r\n      return this.handleFFTError();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts a linear power spectrum to the Mel scale using the MelBanks class.\r\n   *\r\n   * @param linearSpectrum The input power spectrum.\r\n   * @param numberOfMelBands The desired number of Mel bands for this conversion.\r\n   * @returns The Mel scaled spectrum or null if parameters are missing/invalid.\r\n   */\r\n  convertToMelScale(linearSpectrum: Float32Array, numberOfMelBands: number): Float32Array | null {\r\n    if (!this.options.sampleRate) {\r\n      console.warn(\"Sample rate required for Mel scale conversion.\");\r\n      return null;\r\n    }\r\n    if (numberOfMelBands <= 0) {\r\n      console.warn(\"Number of Mel bands must be positive.\");\r\n      return null;\r\n    }\r\n\r\n    const linearBinCount = linearSpectrum.length;\r\n    const currentKey = `${this.options.sampleRate}-${linearBinCount}-${numberOfMelBands}`;\r\n\r\n    // Check cache\r\n    if (!this.melBanksCache || this.melBanksCacheKey !== currentKey) {\r\n      try {\r\n        this.melBanksCache = new MelBanks(this.options.sampleRate, linearBinCount, numberOfMelBands);\r\n        this.melBanksCacheKey = currentKey;\r\n      } catch (error) {\r\n        console.error(\"Failed to create MelBanks instance:\", error);\r\n        this.melBanksCache = null;\r\n        this.melBanksCacheKey = null;\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // Apply the filter bank using the cached instance\r\n    try {\r\n      return this.melBanksCache.applyFilterbank(linearSpectrum);\r\n    } catch (error) {\r\n      console.error(\"Error applying Mel filterbank:\", error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns a fallback array when FFT calculation fails.\r\n   */\r\n  private handleFFTError(): Float32Array | null {\r\n    // Return null to indicate failure, let the caller decide on fallback\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Cleans up the WebFFT instance.\r\n   */\r\n  dispose() {\r\n    this.webfftInstance?.dispose();\r\n    this.webfftInstance = null;\r\n    this.fftInputBuffer = null;\r\n    this.fftInterleavedInputBuffer = null;\r\n    this.melBanksCache = null; // Clear cache on dispose\r\n    this.melBanksCacheKey = null;\r\n  }\r\n\r\n  // Getter for FFT samples size\r\n  get fftSamples(): number {\r\n    return this.options.fftSamples;\r\n  }\r\n}\r\n","/**\r\n * Available window function types for audio processing\r\n */\r\nexport type WindowFunctionType = \"hann\" | \"hamming\" | \"blackman\" | \"rectangular\";\r\n\r\n/**\r\n * Applies a window function to a buffer of audio samples\r\n * @param buffer - The audio samples to apply the window function to\r\n * @param windowType - The type of window function to apply\r\n */\r\nexport function applyWindowFunction(buffer: Float32Array, windowType: WindowFunctionType = \"hann\"): void {\r\n  const n = buffer.length;\r\n\r\n  switch (windowType.toLowerCase()) {\r\n    case \"hann\":\r\n      for (let i = 0; i < n; i++) {\r\n        buffer[i] *= 0.5 * (1 - Math.cos((2 * Math.PI * i) / (n - 1)));\r\n      }\r\n      break;\r\n    case \"hamming\":\r\n      for (let i = 0; i < n; i++) {\r\n        buffer[i] *= 0.54 - 0.46 * Math.cos((2 * Math.PI * i) / (n - 1));\r\n      }\r\n      break;\r\n    case \"blackman\":\r\n      for (let i = 0; i < n; i++) {\r\n        buffer[i] *= 0.42 - 0.5 * Math.cos((2 * Math.PI * i) / (n - 1)) + 0.08 * Math.cos((4 * Math.PI * i) / (n - 1));\r\n      }\r\n      break;\r\n    case \"rectangular\":\r\n      // No window function (rectangular)\r\n      break;\r\n  }\r\n}\r\n"],"names":["MelBanks","constructor","sampleRate","linearBinCount","numBands","filterbank","console","warn","this","createMelFilterbank","applyFilterbank","linearSpectrum","length","Float32Array","fill","error","melSpectrum","i","filter","j","hzToMel","hz","Math","log10","melToHz","mel","highFreqMel","melPoints","melStep","hzPoints","map","freqResolution","binFreqs","_","Array","leftHz","centerHz","rightHz","leftDelta","rightDelta","toFixed","targetBinIndex","round","clampedBinIndex","max","min","freq","push","FFTProcessor","options","webfftInstance","melBanksCache","melBanksCacheKey","fftInputBuffer","fftInterleavedInputBuffer","Object","assign","fftSamples","SPECTROGRAM_DEFAULTS","FFT_SAMPLES","windowingFunction","initialize","webfft","profile","_error","updateParameters","newOptions","needsReinitialization","needsMelCacheClear","_this$webfftInstance","dispose","calculatePowerSpectrum","buffer","handleFFTError","inputSlice","slice","set","windowType","n","toLowerCase","cos","PI","applyWindowFunction","fftResult","fft","validFftResult","spectrumSize","powerSpectrum","normFactor","dcReal","abs","real","imag","sqrt","convertToMelScale","numberOfMelBands","currentKey","_this$webfftInstance2"],"sourceRoot":""}